//---------------------------------------------------------------------
//	文字配置処理(SetWord.cpp)
//	Author : Mikiya Meguro
//---------------------------------------------------------------------
#include "SetWord.h"
#include "game.h"
#include "fade.h"
#include "word.h"
//*****************************************************************************
// マクロ定義
//*****************************************************************************
#define FILE_NAME0				("data\\TEXT\\機械ステージ\\文字出現位置\\Machine_Stage_0.txt")

//--------------------------------------------
//静的メンバ変数宣言
//--------------------------------------------

//--------------------------------------------
//オブジェクトクラス コンストラクタ
//--------------------------------------------
CSetWord::CSetWord() : CScene(3, CScene::OBJTYPE_SETOBJECT)
{
	m_pWordPos = NULL;
	m_pWord = NULL;
}

//--------------------------------------------
//オブジェクトクラス デストラクタ
//--------------------------------------------
CSetWord::~CSetWord()
{
}

//--------------------------------------------
//オブジェクトの生成
//--------------------------------------------
CSetWord *CSetWord::Create()
{
	//オブジェクトポインタ
	CSetWord *pSetObject = NULL;
	if (pSetObject == NULL)
	{
		pSetObject = new CSetWord;
		if (pSetObject != NULL)
		{//オブジェクトの初期化
			pSetObject->Init();
		}
	}
	//オブジェクトの情報を返す
	return pSetObject;
}

//=============================================================================
// オブジェクトの初期化処理
//=============================================================================
HRESULT CSetWord::Init()
{
	//オブジェクト種類の設定
	CScene::SetObjType(CScene::OBJTYPE_SETOBJECT);

	return S_OK;
}

//=============================================================================
// オブジェクトの終了処理
//=============================================================================
void CSetWord::Uninit(void)
{
	if (m_pWordPos != NULL)
	{
		delete[] m_pWordPos;
		m_pWordPos = NULL;
	}

	//自分を消す(オブジェクトを破棄)
	Release();
}

//=============================================================================
// オブジェクトの更新処理
//=============================================================================
void CSetWord::Update(void)
{
}

//=============================================================================
// オブジェクトの描画処理
//=============================================================================
void CSetWord::Draw(void)
{
	//デバイスを取得
	//CRenderer *pRenderer = CManager::GetRenderer();
	//LPDIRECT3DDEVICE9 pDevice = pRenderer->GetDevice();
	//D3DXMATRIX mtxRot, mtxTrans;	//計算用マトリックス
	//D3DXMATRIX mtxParent;

}


//=============================================================================
// オブジェクトの配置情報を読み込み
//=============================================================================
void CSetWord::LoadFile(char *pFileName)
{
	//デバイスを取得
	CRenderer *pRenderer = CManager::GetRenderer();
	LPDIRECT3DDEVICE9 pDevice = pRenderer->GetDevice();

	//ファイル読み込み用変数
	FILE *pFile;			//ファイルポインタ
	char *pStrcur;			//現在の先頭の文字列
	char aLine[256];		//文字列
	char aStr[256];			//一時保存文字列
	int nIndex = 0;			//現在のインデックス
	int nWord = 0;			//ポップで返された値を保持
	int nNumModel = 0;		//モデルの数
	int nType = 0;			//モデルの種類
	int nNum = 0;
	D3DXVECTOR3 ModelPos;	//モデルの位置

	if (m_pWordPos != NULL)
	{
		delete[] m_pWordPos;
		m_pWordPos = NULL;
	}

	if (m_pWord != NULL)
	{
		m_pWord->Uninit();
		delete[] m_pWord;
		m_pWord = NULL;
	}

	//ファイルを開く 読み込み
	pFile = fopen(pFileName, "r");
	//NULLチェック
	if (pFile != NULL)
	{
		while (1)
		{
			//文字列の先頭を設定
			pStrcur = ReadLine(pFile, &aLine[0]);
			//文字列を取り出す
			strcpy(aStr, pStrcur);

			if (memcmp(pStrcur, "ANSWERNUM = ", strlen("ANSWERNUM = ")) == 0)
			{
				//頭出し
				pStrcur += strlen("ANSWERNUM = ");
				//文字列の先頭を設定
				strcpy(aStr, pStrcur);
				//文字列抜き出し
				nNum = atoi(pStrcur);
				//文字列の先頭を設定
				pStrcur = ReadLine(pFile, &aLine[0]);
				if (m_pWord == NULL)
				{
					m_pWord = new CWord[nNum];
				}

				if (m_pWordPos == NULL)
				{
					m_pWordPos = new Word_Pos[nNum];
				}
				//CWordManager::SetWordAnswerNum(nAnswerNum);
			}

			//オブジェクト読み込み
			if (memcmp(pStrcur, "MODELSET", strlen("MODELSET")) == 0)
			{
				//頭出し
				pStrcur += strlen("MODELSET");
				//文字列の先頭を設定
				pStrcur = ReadLine(pFile, &aLine[0]);
				//位置
				if (memcmp(pStrcur, "POS = ", strlen("POS = ")) == 0)
				{
					//頭出し
					pStrcur += strlen("POS = ");
					//文字列の先頭を設定
					strcpy(aStr, pStrcur);

					//文字数を返してもらう
					nWord = PopString(pStrcur, &aStr[0]);
					//POS.X代入
					ModelPos.x = (float)atof(pStrcur);
					//文字数分進める
					pStrcur += nWord;

					//文字数を返してもらう
					nWord = PopString(pStrcur, &aStr[0]);
					//POS.Y代入
					ModelPos.y = (float)atof(pStrcur);
					//文字数分進める
					pStrcur += nWord;

					//文字数を返してもらう
					nWord = PopString(pStrcur, &aStr[0]);
					//POS.Z代入
					ModelPos.z = (float)atof(pStrcur);
					//文字列の先頭を設定
					pStrcur = ReadLine(pFile, &aLine[0]);
				}
			}
			//モデルを生成
			if (memcmp(pStrcur, "END_MODELSET", strlen("END_MODELSET")) == 0)
			{
				//CWord::Create(D3DXVECTOR3(380.0f, 0.0f, 380.0f), 12.0f, 12.0f, "WORD", 38);

			}
			//スクリプトの終わり
			if (memcmp(pStrcur, "END_SCRIPT	", strlen("END_SCRIPT")) == 0)
			{
				break;
			}
		}
	}

	//ファイルを閉じる
	fclose(pFile);
}


//=============================================================================
//　ファイル読み込み無効文を排除
//=============================================================================
char *CSetWord::ReadLine(FILE *pFile, char *pDst)
{
	while (1)
	{
		//１行分読み込み
		fgets(&pDst[0], 256, pFile);

		//文字列のデータ 比較する文字列 比較する文字数
		if (memcmp(pDst, "#", strlen("#")) == 0)
		{
			pDst += strlen("\n");
		}
		//文字列のデータ 比較する文字列 比較する文字数
		else if (memcmp(pDst, "\t", strlen("\t")) == 0)
		{
			pDst += strlen("\t");
			while (1)
			{
				if (memcmp(pDst, "\t", strlen("\t")) == 0)
				{
					pDst += strlen("\t");
				}
				else
				{
					break;
				}
			}
			break;
		}
		//文字列のデータ 比較する文字列 比較する文字数
		else if (memcmp(pDst, " ", strlen(" ")) == 0)
		{
			pDst += strlen(" ");
			while (1)
			{
				if (memcmp(pDst, " ", strlen(" ")) == 0)
				{
					pDst += strlen(" ");
				}
				else
				{
					break;
				}
			}
			break;
		}
		//文字列のデータ 比較する文字列 比較する文字数
		else if (memcmp(pDst, "\n", strlen("\n")) == 0)
		{
			pDst += strlen("\n");
		}
		else
		{
			break;
		}
	}
	return pDst;
}

//=============================================================================
//　ファイル読み込み先頭を排除
//=============================================================================
char * CSetWord::GetLineTop(char * pStr)
{
	while (1)
	{
		//文字列のデータ 比較する文字列 比較する文字数
		if (memcmp(pStr, " ", strlen(" ")) == 0)
		{
			pStr += strlen(" ");
			while (1)
			{
				if (memcmp(pStr, " ", strlen(" ")) == 0)
				{
					pStr += strlen(" ");
				}
				else
				{
					break;
				}
				break;
			}
		}
		//文字列のデータ 比較する文字列 比較する文字数
		else if (memcmp(pStr, "\t", strlen("\t")) == 0)
		{
			pStr += strlen("\t");
			while (1)
			{
				if (memcmp(pStr, "\t", strlen("\t")) == 0)
				{
					pStr += strlen("\t");
				}
				else
				{
					break;
				}
			}
		}
		else
		{
			break;
		}
	}
	return pStr;
}

//=============================================================================
//　文字数を返す
//=============================================================================
int CSetWord::PopString(char * pStr, char * pDest)
{
	int nWord = 0;

	while (1)
	{	//頭出し
		pStr += 1;
		nWord += 1;
		if (memcmp(pStr, " ", strlen(" ")) == 0)
		{	//頭出し
			pStr = "\0";
			nWord += 1;
			break;
		}
		if (memcmp(pStr, "\t", strlen("\t")) == 0)
		{	//頭出し
			pStr = "\0";
			nWord += strlen("\t");
			break;
		}
		//文字列のデータ 比較する文字列 比較する文字数
		else if (memcmp(pStr, "\n", strlen("\n")) == 0)
		{
			//頭出し
			nWord += strlen("\n");
			break;
		}
	}
	strcpy(pDest, pStr);
	//文字列の数を返す
	return nWord;
}
